IMS - internal messaging system (v1.0)

    The basic idea behind IMS is that provide an ability
for application object to communicate with each other
using messages, instead of direct method calls. 

The pros are
    -   that it becomes unified - accessing the fields,
        setting data and etc.
    -   higher flexibility as we can separate invocation into
        synchronous and asynchronous out of box
    -   ability to separate objects into groups with different
        addresses, combining groups and etc.
The cons are
    -   performance drop, due to additional actions

It can be achieved by providing special URL to every object.
There it is called GRL - global resource locator. GRL is an address
in format a:b:c, where every element corresponds to the router. 
Example

    core:managed:componentStorage

    When object support IMS it means that he can send and receive
GRL messages - special objects, that contain information regarding
sender, receive, object etc. It has the type GRLMessage.

GRL message has structure like [method:headers:mutlipart]

    method      -   type of method: POST, PUT, GET. Has type of GRLMethod.
    headers     -   map of headers. For example ["contentType" : "object"]
                    Required headers:
                        -   destination
                        -   identifier
                        -   sender
    multipart   -   object content. Can be any type - JSON, binary etc. Should
                    implement IGRLMultipart interface.

    Messages consumed and produced by objects. In order to send message one need to provide
message itself and also GRL. In order to combine it, IMS operates with special packages.
Package has GRL and GRLMessage. In IMS it has GRLPackage type.

    Sending messages is not happen directly. Before message reach its destination it should pass routers.
Router is a special object - instance of interface IRouter - and responsible for delegating message
to channels and destinations.
    They keep channels - object that can consume message with certain GRL methods. Basically there are three
types of channels POST, PUT, GET - corresponding to GRLMethod.
Channels should implement IChannel interface.
============================================================================================
    The main entry point for IMS is a IMSContext - it keeps all IMS routers and provides
facilities to send packages using them.

    By default IMSContext is empty. In order to use it, there is a need to provide routes.
When user want to add a new route - say channel and router processor,
he should register it in IMS using 

    IMSContext.registerRouter(route, router)

Route is a path. Router is an implementation of IRouter interface.

If user want to register new channel for the router he should add it to IMS

    Router.registerChannel(name, channel)

    Name is a channel label. Channel is an implementation of IChannel interface.
In order to send package using IMS and receive result one should use

    IMSContext.transfer(package)

    In order to send and receive package in IMS system, object should implement interfaces IIMSConsumer
and IIMSProducer. All consumers are asynchronous. The reason behind it is that waiting for the message
when it might not even arrive synchronously is wasting. But producers can be either synchronous or
asynchronous. Synchronous producer sends GRL message and waits for response. Asynchronous producer sends
the message and continue its work further. The response will arrive when it's done.
    Also IMSContext does not operate directly with raw objects - as they can be any type that is ineffective.
In order to use object in IMS user need to wrap it into IMSObject, which extends thread, supply blocking queue
and leverage message consuming.
    When the message is sent, IMS pass it through routers and channels and put into IMSObject blocking queue.
This queue is processed in a thread and wrapped object consumes the message and produce response. Everything
is in background of course.
==============================================================================================
In case of errors, IMS throws IMSException with different messages, depending on the case.
===============================================================================================
API
    IChannel
    IEmptyObject
    IGRLMultipart
    IIMSConsumer
    IIMSIdentifiable
    IIMSProducer
    IRouter
    GRLMessage
    GRLMethod
    GRLPackage
    IMSObject
    IMSContext
    IMSException
==============================================================================================
Currently I am aiming for synchronous producer and asynchronous consumer.
=====
FLOW
    1. Make object implement IIMSConsumer or/and IIMSProducer interfaces. !!! preferably both
    2. Create instance of IMSObject.
    3. Register object in IMSContext and retrieve unique IMS identifier !!!NEW
    4. Send GRLMessages and consume messages asynchronously. !!! somehow leverage with IMSObject
=============================================================================================== v1.0 end
v1.5 expectations
    - persistence
v2.0 expectations
    -   annotations @IMSObject